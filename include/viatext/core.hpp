/**
 * @file core.hpp
 * @brief ViaText Core Node Logic — Main Event and Message Engine
 * @details
 *   This file declares the main logic engine for a ViaText node. The Core class implements:
 *    - All tick-based time advancement and uptime management.
 *    - Message queuing for both input (inbox) and output (outbox).
 *    - Event emission for errors, acknowledgments, and system status.
 *    - Strict queue limits and message validation for robust, bounded operation.
 *    - Platform-agnostic, testable architecture: no hardware or OS dependencies.
 *
 *   ### Design and C++ Notes
 *   - Follows a message-driven, state machine model for resilience and easy reasoning.
 *   - Uses only standard library containers (std::queue, std::string) for compatibility.
 *   - Relies on C++17 features such as `constexpr` and `std::optional` for clarity and safety.
 *   - Time is always supplied by the host system—`Core` never queries the clock directly.
 *   - Designed to be driven by a single `tick()` function, decoupling logic from hardware and simplifying testing.
 *
 *   See the README.md for project overview, design goals, and architecture diagrams. ChatGPT 
 *   assisted in the initial design and implementation.
 *
 *   @author      Leo 
 *   @author      ChatGPT
 *   @date        2025-08-04
 *   @copyright   MIT License
 */


#pragma once

#include <string>     ///< Standard C++ string class for all textual data (IDs, errors, fields).
#include <queue>      ///< FIFO container used for message inbox/outbox (std::queue<T>).
#include <optional>   ///< Represents "maybe" values (std::optional<T>), used for fetches that might be empty.
#include <cstdint>    ///< Fixed-width integer types (e.g., uint64_t), ensuring cross-platform precision.
#include <vector>     ///< Dynamic array container for future extensibility.
#include "viatext/message.hpp" ///< Project message definition, for handling parsed/validated message data.


/**
 * @namespace viatext
 * @brief All core types, logic, and protocol machinery for the ViaText decentralized communication system.
 * @details
 *   The viatext namespace contains all message structures, logic engines, and protocol helpers required to build,
 *   operate, and test nodes on the ViaText mesh network. All system-specific logic (for Linux, Arduino, etc.)
 *   is implemented outside this namespace or in wrapper code, keeping the core library highly portable and reusable.
 *
 *   The project is designed for autonomy, resilience, and minimalism—enabling text-first, decentralized communication
 *   across a variety of platforms (from microcontrollers to full Linux systems).
 *
 *   @author Leo
 *   @author ChatGPT
 */
namespace viatext {

/**
 * @struct Status
 * @brief Snapshot of the core node's state for monitoring and debugging.
 * @details
 *   The Status struct holds a single, immutable report of the node's key runtime metrics,
 *   designed for rapid querying (e.g., for health checks, CLI status display, integration tests).
 *   It is returned by Core's `status()` method and never modified directly by users.
 *
 *   - `uptime_ms`: Total milliseconds since the Core instance was initialized.
 *   - `inbox_size`: Number of pending (unprocessed) incoming messages.
 *   - `outbox_size`: Number of pending outgoing messages/events.
 *   - `errors`: Total number of message validation or processing errors since startup.
 *   - `last_error`: Most recent error message for debugging or logging.
 *
 *   @note
 *     All fields are intentionally public for easy access and to allow simple, header-only struct copying.
 *     This struct is safe to log, serialize, or pass by value.
 */
struct Status {

    /**
     * @brief Total node uptime in milliseconds.
     * @details
     *   This field is incremented on each tick and measures the node's "age" since last reset or start.
     *   Type: `uint64_t` (guaranteed 64-bit unsigned integer).
     */
    uint64_t uptime_ms;

    /**
     * @brief Number of unprocessed messages in the inbox queue.
     */
    size_t inbox_size;

    /**
     * @brief Number of pending messages/events in the outbox queue.
     */
    size_t outbox_size;

    /**
     * @brief Cumulative count of all errors since last reset.
     * @details
     *   Errors are incremented for failed parses, invalid messages, or queue overflows.
     */
    size_t errors;

    /**
     * @brief Last error message generated by the core.
     * @details
     *   May be empty if no errors have occurred yet.
     */
    std::string last_error;
};

/**
 * @class Core
 * @brief The main stateful logic engine for a ViaText node.
 * @details
 *   The Core class manages the full internal state and message/event flow of a ViaText node. It is the
 *   "operating system" for a node: handling time advancement, processing messages from the mesh or user,
 *   tracking uptime and errors, and emitting events or status to the outside world.
 *
 *   ## Design Philosophy
 *   - **State Machine**: Core implements a deterministic, tick-driven event loop, driven by `tick(now)`.
 *   - **Queue-Based Messaging**: All external and internal actions occur via inbox/outbox message queues,
 *     supporting asynchronous, decoupled operation. This mirrors real-world communication patterns and makes
 *     Core easy to test, script, or mock.
 *   - **No Direct IO**: The Core class *never* interacts directly with the filesystem, network, or hardware
 *     peripherals. All I/O is mediated by wrapper code. This guarantees maximum portability.
 *   - **Time is Explicit**: Core does *not* maintain or request the system clock itself. The external wrapper
 *     is responsible for calling `tick()` with the current time, keeping all logic deterministic and testable.
 *   - **Error Transparency**: All errors are tracked internally and surfaced via events and the `Status` struct.
 *     This supports robust monitoring and integration in any environment.
 *   - **Portable and Minimal**: Uses only standard C++ containers and types (no external dependencies).
 *
 *   ## Usage Pattern
 *   1. **Initialize** the core object: `viatext::Core core;`
 *   2. **Feed time**: Call `core.tick(now)` in your main loop, passing current ms since boot/epoch.
 *   3. **Add input**: Queue messages with `core.add_message(json_string)`.
 *   4. **Fetch output**: After each tick, call `core.fetch_message()` to get any events/messages/errors.
 *   5. **Monitor**: Query `core.status()` at any time for health and diagnostics.
 *
 *   ## C++ Features Used
 *   - **constexpr**: For queue size/message size limits—enforces these are true constants at compile-time.
 *   - **std::queue**: Ensures strict FIFO processing of messages/events.
 *   - **std::optional**: Used to express the "maybe" result of `fetch_message()`.
 *   - **Using Alias**: `using timepoint_t` gives a meaningful name and makes units clear (ms).
 *   - **Encapsulation**: All state is private except via API methods or the `Status` struct, ensuring no accidental misuse.
 *
 *   ## Extending Core
 *   - Add new message types or event handlers via the `handle_message()` method.
 *   - Increase queue/message size limits as needed by editing the `constexpr` values.
 *   - The tick/process/add/fetch pattern generalizes to many kinds of mesh, IoT, or event-driven systems.
 *
 *   @author Leo
 *   @author ChatGPT
 *   @date   2025-08-04
 */
class Core {
public:
    /**
     * @brief Alias for representing timepoints, always in milliseconds.
     * @details
     *   This type defines the unit of time used throughout the Core API: milliseconds since
     *   boot or epoch. Using a type alias clarifies intent and allows for easy refactoring.
     *   Chosen as `uint64_t` to guarantee a large, unsigned range (over 500,000 years before wrap!).
     *
     *   Example: `timepoint_t now = 1627789200000;`
     */
    using timepoint_t = uint64_t; // ms since boot or epoch

        /**
     * @brief Maximum allowed messages in the inbox or outbox queue.
     * @details
     *   This compile-time constant enforces a strict upper bound on queue length,
     *   preventing unbounded memory usage in constrained systems.
     *   Marked as `constexpr` for zero runtime overhead.
     */
    static constexpr size_t MAX_QUEUE = 16;

    /**
     * @brief Maximum allowed message size (in characters).
     * @details
     *   Messages exceeding this limit are rejected for safety and robustness.
     *   This helps defend against malformed or malicious input.
     */
    static constexpr size_t MAX_MSG_LEN = 256;

    /**
     * @brief Default constructor.
     * @details
     *   Initializes all counters, timers, and queues to their default states.
     *   No parameters required; Core is always ready to use after construction.
     */
    Core();

    /**
     * @brief Advance the core's internal clock and process events.
     * @param now  Current time in milliseconds (since boot or epoch).
     * @details
     *   This method must be called regularly (e.g., in the main event loop) to move the system forward.
     *   - Handles elapsed time, updates uptime, and triggers internal processing.
     *   - Accepts any monotonically increasing time source; negative jumps are ignored.
     */
    void tick(timepoint_t now);

     /**
     * @brief Add a new incoming message (JSON string) to the inbox queue.
     * @param msg_json  The raw message, typically JSON (but could be protocol string in other builds).
     * @return true if successfully queued, false if rejected (overflow or invalid format).
     * @details
     *   This method does *not* process the message immediately; processing occurs on the next tick.
     *   Messages exceeding `MAX_MSG_LEN` or overflowing the inbox are rejected with error reporting.
     */   
    bool add_message(const std::string& msg_json);

    /**
     * @brief Fetch the next outgoing message/event/error for the wrapper or user.
     * @return Optional string: the next pending message, or nullopt if none available.
     * @details
     *   Outgoing messages are returned in strict FIFO order.
     *   After each tick, call this repeatedly to drain the outbox if needed.
     */
    std::optional<std::string> fetch_message();

    /**
     * @brief Query a snapshot of the node's current state.
     * @return Status struct with uptime, queue sizes, error count, and last error message.
     * @details
     *   This is a cheap, non-destructive operation; call at any time for diagnostics or monitoring.
     */
    Status status() const;

private:

    /**
     * @brief Time of the last tick (ms since boot or epoch).
     * @details
     *   Used to calculate elapsed time for uptime and to prevent time regressions.
     *   Always updated with each call to `tick()`.
     *   Type: `timepoint_t` (`uint64_t`).
     */
    timepoint_t last_tick_ = 0;

    /**
     * @brief Total system uptime (ms since construction).
     * @details
     *   Incremented on each tick by the elapsed time. Used for diagnostics and event timing.
     */
    timepoint_t uptime_ = 0;

    /**
     * @brief Total error count since core construction.
     * @details
     *   Incremented for every failed validation, parse, or overflow.
     */
    size_t errors_ = 0;

    /**
     * @brief Most recent error message encountered by the system.
     * @details
     *   Used for status display, diagnostics, and event reporting.
     */
    std::string last_error_;

    /**
     * @brief Queue of incoming messages to be processed (FIFO).
     * @details
     *   Messages are added via `add_message()` and consumed by `process()`.
     *   Uses `std::queue` for strict FIFO order.
     *   Capacity is bounded by `MAX_QUEUE`.
     */   
    std::queue<std::string> inbox_;

    /**
     * @brief Queue of outgoing messages/events/errors for wrapper/user (FIFO).
     * @details
     *   Populated by event handlers, drained by `fetch_message()`.
     *   Capacity is bounded by `MAX_QUEUE`.
     */
    std::queue<std::string> outbox_;

    /**
     * @brief Internal engine for processing one or more messages/events per tick.
     * @details
     *   Called on each `tick()` to move system forward: consumes from inbox,
     *   invokes handlers, and pushes results to outbox.
     *   May be extended to process all messages, or limited to one per tick for fairness.
     */
    void process();

    /**
     * @brief Main handler for a single message.
     * @param msg_json The message to process (JSON or protocol string).
     * @return true if processed successfully, false on error.
     * @details
     *   All parsing/validation should be delegated to the parser module.
     *   Specialized actions (directives, mesh messages) handled here.
     */
    bool handle_message(const std::string& msg_json);

    /**
     * @brief Helper for pushing errors/events to the outbox as messages.
     * @param type   Type of event (e.g., "error", "ack", "status").
     * @param detail Detail string (human-readable message).
     * @details
     *   Outbox capacity is checked before pushing to avoid overflow.
     */   
    void post_event(const std::string& type, const std::string& detail);

    /**
     * @brief Validates the structure and size of an incoming message.
     * @param msg The raw incoming message.
     * @return true if message is valid and within allowed limits, false otherwise.
     * @details
     *   This is a quick, non-throwing check to prevent obvious errors and resource abuse.
     */   
    bool validate_message(const std::string& msg) const;
};

} // namespace viatext
